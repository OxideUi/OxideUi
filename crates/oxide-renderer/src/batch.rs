//! Draw command batching for efficient rendering

use oxide_core::types::{Color, Rect, Transform, Point};
use crate::vertex::Vertex;
use smallvec::SmallVec;

/// Draw command types
#[derive(Debug, Clone)]
pub enum DrawCommand {
    /// Draw a solid rectangle
    Rect {
        rect: Rect,
        color: Color,
        transform: Transform,
    },
    /// Draw a textured rectangle
    TexturedRect {
        rect: Rect,
        texture_id: u32,
        color: Color,
        transform: Transform,
    },
    /// Draw text
    Text {
        text: String,
        position: (f32, f32),
        color: Color,
        font_size: f32,
    },
    /// Draw a path
    Path {
        vertices: Vec<Vertex>,
        indices: Vec<u32>,
        color: Color,
        transform: Transform,
    },
    /// Set clip rectangle
    SetClip(Option<Rect>),
    /// Push transform
    PushTransform(Transform),
    /// Pop transform
    PopTransform,
}

/// A contiguous slice of the index buffer that shares the same clip state
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct DrawSegment {
    pub start_index: u32,
    pub index_count: u32,
    pub clip: Option<Rect>,
}

/// Render batch for collecting draw commands
pub struct RenderBatch {
    commands: Vec<DrawCommand>,
    vertices: Vec<Vertex>,
    indices: Vec<u32>,
    segments: Vec<DrawSegment>,
    transform_stack: SmallVec<[Transform; 8]>,
    clip_stack: SmallVec<[Option<Rect>; 8]>,
}

impl RenderBatch {
    /// Create a new render batch
    pub fn new() -> Self {
        Self {
            commands: Vec::new(),
            vertices: Vec::new(),
            indices: Vec::new(),
            segments: Vec::new(),
            transform_stack: SmallVec::from_elem(Transform::identity(), 1),
            clip_stack: SmallVec::from_elem(None, 1),
        }
    }

    /// Add a draw command
    pub fn add_command(&mut self, command: DrawCommand) {
        self.commands.push(command);
    }

    /// Draw a rectangle
    pub fn draw_rect(&mut self, rect: Rect, color: Color) {
        let transform = self.current_transform();
        let clip = *self.clip_stack.last().unwrap();

        self.add_command(DrawCommand::Rect {
            rect,
            color,
            transform,
        });
        
        // Generate transformed vertices (CPU-baked)
        // Original corners (top-left, top-right, bottom-right, bottom-left)
        let p0 = transform.transform_point(Point::new(rect.x, rect.y));
        let p1 = transform.transform_point(Point::new(rect.x + rect.width, rect.y));
        let p2 = transform.transform_point(Point::new(rect.x + rect.width, rect.y + rect.height));
        let p3 = transform.transform_point(Point::new(rect.x, rect.y + rect.height));

        // Base vertex index for this rect (before pushing 4 vertices)
        let base_vertex = self.vertices.len() as u32;

        self.vertices.push(Vertex::new([p0.x, p0.y, 0.0], color, [0.0, 0.0]));
        self.vertices.push(Vertex::new([p1.x, p1.y, 0.0], color, [1.0, 0.0]));
        self.vertices.push(Vertex::new([p2.x, p2.y, 0.0], color, [1.0, 1.0]));
        self.vertices.push(Vertex::new([p3.x, p3.y, 0.0], color, [0.0, 1.0]));
        
        // Indices for two triangles. start_index is the offset into the index buffer (used by draw_indexed),
        // while values we push reference vertex indices via base_vertex.
        let start_index = self.indices.len() as u32;
        self.indices.extend_from_slice(&[
            base_vertex + 0, base_vertex + 1, base_vertex + 2,
            base_vertex + 0, base_vertex + 2, base_vertex + 3,
        ]);

        // Update segments: merge with last if same clip, else start a new segment
        let added = 6u32;
        match self.segments.last_mut() {
            Some(last) if last.clip == clip => {
                last.index_count += added;
            }
            _ => {
                self.segments.push(DrawSegment { start_index, index_count: added, clip });
            }
        }
    }

    /// Draw a rounded rectangle
    pub fn draw_rounded_rect(&mut self, rect: Rect, color: Color, _radius: f32) {
        // For now, just draw a regular rect
        // TODO: Implement proper rounded rectangle with lyon
        self.draw_rect(rect, color);
    }

    /// Draw text
    pub fn draw_text(&mut self, text: &str, position: (f32, f32), color: Color, font_size: f32) {
        let _transform = self.current_transform();
        self.add_command(DrawCommand::Text {
            text: text.to_string(),
            position,
            color,
            font_size,
        });
        // Geometry for text will be generated by TextRenderer in a later step
    }

    /// Push a transform
    pub fn push_transform(&mut self, transform: Transform) {
        let current = self.current_transform();
        self.transform_stack.push(current.combine(&transform));
        self.add_command(DrawCommand::PushTransform(transform));
    }

    /// Pop a transform
    pub fn pop_transform(&mut self) {
        if self.transform_stack.len() > 1 {
            self.transform_stack.pop();
            self.add_command(DrawCommand::PopTransform);
        }
    }

    /// Set clip rectangle
    pub fn set_clip(&mut self, clip: Option<Rect>) {
        self.clip_stack.push(clip);
        self.add_command(DrawCommand::SetClip(clip));
    }

    /// Clear clip rectangle
    pub fn clear_clip(&mut self) {
        if self.clip_stack.len() > 1 {
            self.clip_stack.pop();
            let prev_clip = self.clip_stack.last().copied().flatten();
            self.add_command(DrawCommand::SetClip(prev_clip));
        }
    }

    /// Get current transform
    fn current_transform(&self) -> Transform {
        *self.transform_stack.last().unwrap()
    }

    /// Clear the batch
    pub fn clear(&mut self) {
        self.commands.clear();
        self.vertices.clear();
        self.indices.clear();
        self.segments.clear();
        self.transform_stack.clear();
        self.transform_stack.push(Transform::identity());
        self.clip_stack.clear();
        self.clip_stack.push(None);
    }

    /// Get vertices
    pub fn vertices(&self) -> &[Vertex] {
        &self.vertices
    }

    /// Get indices
    pub fn indices(&self) -> &[u32] {
        &self.indices
    }

    /// Get commands
    pub fn commands(&self) -> &[DrawCommand] {
        &self.commands
    }

    /// Get draw segments
    pub fn segments(&self) -> &[DrawSegment] {
        &self.segments
    }

    /// Check if batch is empty
    pub fn is_empty(&self) -> bool {
        self.commands.is_empty()
    }

    /// Get rendering statistics
    pub fn stats(&self) -> BatchStats {
        BatchStats {
            vertex_count: self.vertices.len(),
            index_count: self.indices.len(),
            command_count: self.commands.len(),
            draw_call_count: self.segments.len(),
        }
    }

    /// Calculate number of draw calls (deprecated by segments)
    fn calculate_draw_calls(&self) -> usize {
        // Kept for compatibility with earlier versions; not used in stats anymore
        // Simple heuristic: group consecutive similar commands
        let mut draw_calls = 0;
        let mut last_type = None;
        
        for cmd in &self.commands {
            let cmd_type = match cmd {
                DrawCommand::Rect { .. } => 0,
                DrawCommand::TexturedRect { .. } => 1,
                DrawCommand::Text { .. } => 2,
                DrawCommand::Path { .. } => 3,
                _ => 4,
            };
            
            if Some(cmd_type) != last_type {
                draw_calls += 1;
                last_type = Some(cmd_type);
            }
        }
        
        draw_calls
    }
}

impl Default for RenderBatch {
    fn default() -> Self {
        Self::new()
    }
}

/// Batch statistics
#[derive(Debug, Clone)]
pub struct BatchStats {
    pub command_count: usize,
    pub vertex_count: usize,
    pub index_count: usize,
    pub draw_call_count: usize,
}
